p <- 2/3
n <- 90
rx <- rbinom(N, n, p)
hist(rx)
## Consider all the possible observed values for X
## Calculate confidence intervals using the Wald and Agresti-Coull Methods
df <- tibble(
n = rep(90, 91), # repeat the value '90' for 91(as x starts from 0) times.
x = 0:90,
p_hat = x/n,
p_tilde = (x+2)/(n+4),
se_wald = binom_se(n,p_hat),
se_agresti = binom_se(n+4, p_tilde),
a_wald = p_hat - qnorm(0.975)*se_wald,
b_wald = p_hat + qnorm(0.975)*se_wald,
a_agresti = p_tilde - qnorm(0.975)*se_agresti,
b_agresti = p_tilde + qnorm(0.975)*se_agresti
)
## Find the range of Wald intervals that would capture our p = 2/3
df_wald <- df %>%
filter(a_wald <= p & p <= b_wald) %>%
summarize(minx=min(x), maxx=max(x))
df_wald
## Estimated Wald coverage probability
mean(rx >= df_wald$minx & rx <=df_wald$maxx)
## Find the range of Agresti-Coull intervals that would capture our p = 2/3
df_agresti <- df%>%
filter(a_agresti <= p & p <= b_agresti) %>%
summarize(minx = min(x), maxx=max(x))
df_agresti
## Estimated Agresti-Coull coverage probability
mean(rx >= df_agresti$minx & rx <=df_agresti$maxx)
## Calculate the coverage probability
calc_wald <- function(n, p, conf=0.95){
z <- qnorm(1- (1-conf) / 2)
df <- tibble(
x = 0:n,
d = dbinom(x, n, p),
p_hat = x/n,
se = sqrt(p_hat*(1-p_hat)/n),
a = p_hat - z*se,
b = p_hat + z*se)
prob <- df %>%
filter(a < p & p < b) %>%
pull(prob)
return (prob)
}
capture_wald <- function(n, seq_p, conf=0.95){
prob <- numeric(length(seq_p))
for ( i in 1:length(seq_p))
prob[i] <- calc_wald(n, seq_p[i], conf)
df <- tibble(p=seq_p, prob=prob)
return (df)
}
plot_wald <- function(n, seq_p, conf=0.95){
capture_wald(90, seq(0.1, 0.9, 0.005)) %>%
ggplot(aes(x=p, y=prob)) +
geom_line(...) +
geom_hline(yintercept=conf, linetype="dashed") +
ggtitle("Wald Method Capture Probability", subtitle = paste("n =", n)) +
theme_bw()
}
plot_wald(90, seq(0.1, 0.9, length.out=501), conf=0.95, color="red")
## Calculate the coverage probability
calc_wald <- function(n, p, conf=0.95){
z <- qnorm(1- (1-conf) / 2)
df <- tibble(
x = 0:n,
d = dbinom(x, n, p),
p_hat = x/n,
se = sqrt(p_hat*(1-p_hat)/n),
a = p_hat - z*se,
b = p_hat + z*se)
prob <- df %>%
filter(a < p & p < b) %>%
pull(prob)
return (prob)
}
capture_wald <- function(n, seq_p, conf=0.95){
prob <- numeric(length(seq_p))
for ( i in 1:length(seq_p))
prob[i] <- calc_wald(n, seq_p[i], conf)
df <- tibble(p=seq_p, prob=prob)
return (df)
}
plot_wald <- function(n, seq_p, conf=0.95,...){
capture_wald(90, seq(0.1, 0.9, 0.005)) %>%
ggplot(aes(x=p, y=prob)) +
geom_line(...) +
geom_hline(yintercept=conf, linetype="dashed") +
ggtitle("Wald Method Capture Probability", subtitle = paste("n =", n)) +
theme_bw()
}
plot_wald(90, seq(0.1, 0.9, length.out=501), conf=0.95, color="red")
## Calculate the coverage probability
calc_wald <- function(n,p,conf=0.95)
{
z <- qnorm(1 - (1-conf)/2)
df <- tibble(
x = 0:n,
d = dbinom(x,n,p), # we use dbinom instead of simulating with rbinom
p_hat = x/n,
se = sqrt( p_hat*(1-p_hat)/n ),
a = p_hat - z*se,
b = p_hat + z*se)
prob <- df %>%
filter(a < p & p < b) %>%
summarize(prob = sum(d)) %>%
pull(prob)
return ( prob )
}
capture_wald <- function(n,seq_p,conf=0.95)
{
prob <- numeric(length(seq_p))
for ( i in 1:length(seq_p))
prob[i] <- calc_wald(n,seq_p[i],conf)
df <- tibble(p = seq_p,prob=prob)
return ( df )
}
plot_wald <- function(n,seq_p,conf=0.95,...)
{
capture_wald(90,seq(0.1,0.9,0.005)) %>%
ggplot(aes(x=p,y=prob)) +
geom_line(...) +
geom_hline(yintercept = conf, linetype = "dashed") +
ggtitle("Wald Method Capture Probability",
subtitle = paste("n = ",n)) +
theme_bw()
}
plot_wald(90,seq(0.1,0.9,length.out=501),conf=0.95,color="red")
calc_agresti <- function(n,p,conf=0.95){
z = qnorm(1- (1-conf) / 2)
df <- tibble(
x = 0:n,
d = dbinom(x, n, p),
p_tilde = (x+2)/(n+4),
se = sqrt(p_tilde*(1-ptilde) / (n+4)),
a = p_tilde - z*se,
b = p_tilde + z*se)
prob <- df %>%
filter(a < p & p < b) %>%
summarize(prob=sum(d)) %>%
pull(prob)
return (prob)
}
calc_agresti <- function(n,p,conf=0.95){
z = qnorm(1- (1-conf) / 2)
df <- tibble(
x = 0:n,
d = dbinom(x, n, p),
p_tilde = (x+2)/(n+4),
se = sqrt(p_tilde*(1-ptilde) / (n+4)),
a = p_tilde - z*se,
b = p_tilde + z*se)
prob <- df %>%
filter(a < p & p < b) %>%
summarize(prob=sum(d)) %>%
pull(prob)
return (prob)
}
capture_agresti <- function(n, seq_p, conf=0.95) {
prob <- numeric(length(seq_p))
for (i in 1:length(seq_p))
prob[i] <- calc_agresti(n, seq_p[i], conf)
df <- tibble(p=seq_p, prob=prob)
return (df)
}
plot_agresti <- function(n, seq_p, conf=0.95, ...){
capture_agresti(90, seq(0.1, 0.9, 0.005)) %>%
ggplot(aes(x=p, y=prob)) +
geom_line(...) +
geom_hline(yintercept=conf, linetype="dashed") +
ggtitle("Agresti-Coull Method Capture Probability",
subtitle = paste("n = ", n)) +
theme_bw()
}
plot_agresti(90, seq(0.1, 0.9, length.out =501), conf=0.95, color="red")
calc_agresti <- function(n,p,conf=0.95)
{
z <- qnorm(1 - (1-conf)/2)
df <- tibble(
x = 0:n,
d = dbinom(x,n,p),
p_tilde = (x+2)/(n+4),
se = sqrt( p_tilde*(1-p_tilde)/(n+4) ),
a = p_tilde - z*se,
b = p_tilde + z*se)
prob <- df %>%
filter(a < p & p < b) %>%
summarize(prob = sum(d)) %>%
pull(prob)
return ( prob )
}
capture_agresti <- function(n,seq_p,conf=0.95)
{
prob <- numeric(length(seq_p))
for ( i in 1:length(seq_p))
prob[i] <- calc_agresti(n,seq_p[i],conf)
df <- tibble(p = seq_p,prob=prob)
return ( df )
}
plot_agresti <- function(n,seq_p,conf=0.95,...)
{
capture_agresti(90,seq(0.1,0.9,0.005)) %>%
ggplot(aes(x=p,y=prob)) +
geom_line(...) +
geom_hline(yintercept = conf, linetype = "dashed") +
ggtitle("Agresti-Coull Method Capture Probability",
subtitle = paste("n = ",n)) +
theme_bw()
}
plot_agresti(90,seq(0.1,0.9,length.out=501),conf=0.95,color="red")
n <- 90
p <- 2/3
gbinom(n, p)
df
df <- tibble(pseq=seq(0,1,by=0.01), L=dbinom(x,n,pseq))
set.seed(1234)
n<-90
x<-rbinom(1,n,p=2/3) # generate an observed x
df <- tibble(pseq=seq(0,1,by=0.01), L=dbinom(x,n,pseq))
df
set.seed(1234)
n<-90
x<-rbinom(1,n,p=2/3) # generate an observed x
df <- tibble(pseq=seq(0,1,by=0.01), L=dbinom(x,n,pseq))
ggplot(df, aes(pseq, L)) +
geom_point() +
xlab("p") +
ylab("L(p | X=x)") +
ggtitle(pasteO("L(p|X=", x, ")")) +
geom_vline(xintercept=x/n, color="red", linetype="dashed")
set.seed(1234)
n <- 90
x <- rbinom(1,n,p=2/3) # generate an observed x
df <- tibble(pseq=seq(0,1,by=.01), L=dbinom(x,n,pseq))
ggplot(df, aes(pseq, L)) +
geom_point() +
xlab("p") +
ylab("L(p | X=x)") +
ggtitle(paste0("L(p|X=",x,")")) +
geom_vline(xintercept=x/n, color="red",linetype="dashed")
## Run this code a few more times (avoiding the set.seed)
## Try inputing a low value for x - what happens to the likelihood function?
knitr::opts_chunk$set(echo=TRUE,message=FALSE,warning=FALSE,cache=TRUE,autodep=TRUE,cache.comments=FALSE)
library(tidyverse)
library(lubridate)
source("../../scripts/viridis.R")
source("../../scripts/ggprob.R")
X <- 60
n <- 90
p_hat <- round(60/90,3)
p_hat
## Possible estimate for the SE
round(sqrt(p_hat*(1-p_hat)/n),3)
qnorm((1-0.95)/2)
qnorm((1-0.9)/2)
qnorm((1-0.8)/2)
p_hat <- .55
se_p <- .10
a <- .3855
b <- .7145
## Find margin of error for interval
me <- p_hat - a
me
## Find the standard normal quantile:  me = z*se
z <- me / se_p
z
gnorm(mu=0, sigma=1, a=-4, b=4) +
geom_vline(aes(xintercept=z), color="red", linetype="dashed") +
geom_vline(aes(xintercept=-z), color="red", linetype="dashed")
## Find the tail probability
gnorm(mu=0, sigma=1) +
geom_vline(aes(xintercept=z), color="red", linetype="dashed") +
geom_vline(aes(xintercept=-z), color="red", linetype="dashed") +
geom_norm_fill(a=-4,b=-z, fill="cyan") +
geom_norm_fill(a=z, b=4, fill="cyan")
1 - pnorm(z) + pnorm(-z)# tail probability
2 * pnorm(-z)# by symmetry of the normal density curve
## Hence, the confidence level is
1 - 2*pnorm(-z)
pnorm(z) - pnorm(-z)
binom_se <- function(n, p){
return (sqrt( (p * (1-p)) /n))
}
binom_ci <- function(est, se, conf){
z <- qnorm(1 - (1-conf)/2)
me <- z * se
ci <- est + c(-1, 1) * me
return (ci)
}
x<- 60
n <- 90
p_hat <- x/n
se_wald = binom_se(n, p_hat)
se_wald
ci_wald <- binom_ci(p_hat, se_wald, 0.95)
ci_wald
x <- 60
n <- 90
p_tilde <- (x+2) / (n+4)
p_tilde
se_agresti <- binom_se(n+4, p_tilde)
se_agresti
ci_agresti <- binom_ci(p_tilde, se_agresti, 0.95)
ci_agresti
set.seed(123)
## Generate data
n <- 90
p <- 0.25
x <- rbinom(1, n, p)
x
## Compute our point estimates
p_hat <- x / n
p_hat
p_tilde <- (x+2) / (n+4)
p_tilde
se_wald <- binom_se(n, p_hat)
se_wald
ci_wald <- binom_ci(p_hat, se_wald, 0.95)
se_agrsti <- binom_se(n+4, p_tilde)
se_agresti
ci_agresti <- binom_ci(p_tilde, se_agresti, 0.95)
rbind(ci_wald, ci_agresti)
set.seed(123)
n <- 90
p <- 0.25
N <- 1000 # Number of repetitions
captured_p <- rep(NA, N)
for (i in 1:N) {
x <- rbinom(1, n, p)
p_hat <- x / n
se_wald <- binom_se(n, p_hat)
a_wald <- p_hat - qnorm(0.975) * se_wald
b_wald <- p_hat + qnorm(0.975) * se_wald
captured_p[i] <- ifelse(a_wald <= p & b_wald >= p, 1, 0)
}
## How many intervals captured our p?
sum(captured_p)
## What's our estimate for the capture probability?
mean(captured_p)
## Try running the above code a few more times (be sure to avoid the set.seed() command or you will keep getting the same answer)
## Try changing the value of N
set.seed(96573)
N <- 1000000 # Number of repetitions
p <- 2/3
n <- 90
rx <- rbinom(N, n, p)
hist(rx)
## Consider all the possible observed values for X
## Calculate confidence intervals using the Wald and Agresti-Coull Methods
df <- tibble(
n = rep(90, 91), # repeat the value '90' for 91(as x starts from 0) times.
x = 0:90,
p_hat = x/n,
p_tilde = (x+2)/(n+4),
se_wald = binom_se(n,p_hat),
se_agresti = binom_se(n+4, p_tilde),
a_wald = p_hat - qnorm(0.975)*se_wald,
b_wald = p_hat + qnorm(0.975)*se_wald,
a_agresti = p_tilde - qnorm(0.975)*se_agresti,
b_agresti = p_tilde + qnorm(0.975)*se_agresti
)
## Find the range of Wald intervals that would capture our p = 2/3
df_wald <- df %>%
filter(a_wald <= p & p <= b_wald) %>%
summarize(minx=min(x), maxx=max(x))
df_wald
## Estimated Wald coverage probability
mean(rx >= df_wald$minx & rx <=df_wald$maxx)
## Find the range of Agresti-Coull intervals that would capture our p = 2/3
df_agresti <- df%>%
filter(a_agresti <= p & p <= b_agresti) %>%
summarize(minx = min(x), maxx=max(x))
df_agresti
## Estimated Agresti-Coull coverage probability
mean(rx >= df_agresti$minx & rx <=df_agresti$maxx)
df
knitr::opts_chunk$set(echo=TRUE,message=FALSE,warning=FALSE,cache=TRUE,autodep=TRUE,cache.comments=FALSE)
library(tidyverse)
library(lubridate)
source("../../scripts/viridis.R")
source("../../scripts/ggprob.R")
X <- 60
n <- 90
p_hat <- round(60/90,3)
p_hat
## Possible estimate for the SE
round(sqrt(p_hat*(1-p_hat)/n),3)
qnorm((1-0.95)/2)
qnorm((1-0.9)/2)
qnorm((1-0.8)/2)
p_hat <- .55
se_p <- .10
a <- .3855
b <- .7145
## Find margin of error for interval
me <- p_hat - a
me
## Find the standard normal quantile:  me = z*se
z <- me / se_p
z
gnorm(mu=0, sigma=1, a=-4, b=4) +
geom_vline(aes(xintercept=z), color="red", linetype="dashed") +
geom_vline(aes(xintercept=-z), color="red", linetype="dashed")
## Find the tail probability
gnorm(mu=0, sigma=1) +
geom_vline(aes(xintercept=z), color="red", linetype="dashed") +
geom_vline(aes(xintercept=-z), color="red", linetype="dashed") +
geom_norm_fill(a=-4,b=-z, fill="cyan") +
geom_norm_fill(a=z, b=4, fill="cyan")
1 - pnorm(z) + pnorm(-z)# tail probability
2 * pnorm(-z)# by symmetry of the normal density curve
## Hence, the confidence level is
1 - 2*pnorm(-z)
pnorm(z) - pnorm(-z)
binom_se <- function(n, p){
return (sqrt( (p * (1-p)) /n))
}
binom_ci <- function(est, se, conf){
z <- qnorm(1 - (1-conf)/2)
me <- z * se
ci <- est + c(-1, 1) * me
return (ci)
}
x<- 60
n <- 90
p_hat <- x/n
se_wald = binom_se(n, p_hat)
se_wald
ci_wald <- binom_ci(p_hat, se_wald, 0.95)
ci_wald
x <- 60
n <- 90
p_tilde <- (x+2) / (n+4)
p_tilde
se_agresti <- binom_se(n+4, p_tilde)
se_agresti
ci_agresti <- binom_ci(p_tilde, se_agresti, 0.95)
ci_agresti
set.seed(123)
## Generate data
n <- 90
p <- 0.25
x <- rbinom(1, n, p)
x
## Compute our point estimates
p_hat <- x / n
p_hat
p_tilde <- (x+2) / (n+4)
p_tilde
se_wald <- binom_se(n, p_hat)
se_wald
ci_wald <- binom_ci(p_hat, se_wald, 0.95)
se_agrsti <- binom_se(n+4, p_tilde)
se_agresti
ci_agresti <- binom_ci(p_tilde, se_agresti, 0.95)
rbind(ci_wald, ci_agresti)
set.seed(123)
n <- 90
p <- 0.25
N <- 1000 # Number of repetitions
captured_p <- rep(NA, N)
for (i in 1:N) {
x <- rbinom(1, n, p)
p_hat <- x / n
se_wald <- binom_se(n, p_hat)
a_wald <- p_hat - qnorm(0.975) * se_wald
b_wald <- p_hat + qnorm(0.975) * se_wald
captured_p[i] <- ifelse(a_wald <= p & b_wald >= p, 1, 0)
}
## How many intervals captured our p?
sum(captured_p)
## What's our estimate for the capture probability?
mean(captured_p)
## Try running the above code a few more times (be sure to avoid the set.seed() command or you will keep getting the same answer)
## Try changing the value of N
set.seed(96573)
N <- 1000000 # Number of repetitions
p <- 2/3
n <- 90
rx <- rbinom(N, n, p)
hist(rx)
## Consider all the possible observed values for X
## Calculate confidence intervals using the Wald and Agresti-Coull Methods
df <- tibble(
n = rep(90, 91), # repeat the value '90' for 91(as x starts from 0) times.
x = 0:90,
p_hat = x/n,
p_tilde = (x+2)/(n+4),
se_wald = binom_se(n,p_hat),
se_agresti = binom_se(n+4, p_tilde),
a_wald = p_hat - qnorm(0.975)*se_wald,
b_wald = p_hat + qnorm(0.975)*se_wald,
a_agresti = p_tilde - qnorm(0.975)*se_agresti,
b_agresti = p_tilde + qnorm(0.975)*se_agresti
)
df
## Find the range of Wald intervals that would capture our p = 2/3
df_wald <- df %>%
filter(a_wald <= p & p <= b_wald) %>%
summarize(minx=min(x), maxx=max(x))
df_wald
## Estimated Wald coverage probability
mean(rx >= df_wald$minx & rx <=df_wald$maxx)
## Find the range of Agresti-Coull intervals that would capture our p = 2/3
df_agresti <- df%>%
filter(a_agresti <= p & p <= b_agresti) %>%
summarize(minx = min(x), maxx=max(x))
df_agresti
## Estimated Agresti-Coull coverage probability
mean(rx >= df_agresti$minx & rx <=df_agresti$maxx)

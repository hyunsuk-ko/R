---
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message=FALSE)
library(tidyverse)
library(scales)
library(lubridate)
source("../../scripts/viridis.R")
```

## Assignment 5

### HYUN KO

#### Due Friday, October 2, 11:59pm CT

The purpose of this assignment is to give you practice using lubridate commands and to review dplyr, ggplot2, and basic exploratory data analysis skills.

Turn in an HTML file and this R Markdown file after you have edited it.

### Data

The questions involve five data sets involving international flights arriving to Chicago's O'Hare airport from January 1, 2016 through June 30, 2020
with one separate file for each year.

Each data set is in five separate CSV files:
`ORD-2016.csv`, `ORD-2017.csv`, `ORD-2018.csv`, `ORD-2019.csv`, and `ORD-2020.csv`.

### Problems

### 1

> Read in the five data sets. 
If needed, change the date variable into date format.
(The date is recorded inconsistently across the data sets.)
Use `bind_rows()` to combine these data sets into a single data set.
Add columns for *year*, *month* (character valued, Jan-Dec),
*day* (day of the month), and *wday* (day of the week, character valued, Sun - Sat).
Reorder the variables so that these new variables all appear directly after date.
Remove the terminal variable.
Rename *all_total* to *passengers*, *all_flights* to *flights*, and *all_booths* to *booths*.
Arrange the rows by date and hour.
Remove the data sets from each individual year (use `rm()`).

> After these changes, how many rows and columns are in the complete data set?
Total 29450 Rows and 24 columns.

```{r problem-1}
Sys.setlocale("LC_TIME", "English_United States.1252") 
ord2016 = read_csv("../../data/ORD-2016.csv") %>% mutate(date = mdy(date))
ord2017 = read_csv("../../data/ORD-2017.csv") %>% mutate(date = mdy(date))
ord2018 = read_csv("../../data/ORD-2018.csv") %>% mutate(date = mdy(date))
ord2019 = read_csv("../../data/ORD-2019.csv") 
ord2020 = read_csv("../../data/ORD-2020.csv") 

ord <- bind_rows(ord2016, ord2017, ord2018, ord2019, ord2020) %>%
  mutate(year=year(date), month=month(date, label=TRUE), day=day(date),
         wday=wday(date, label=TRUE)) %>%
  select(airport, terminal, date, year, month, day, wday, everything()) %>%
  select(-terminal) %>%
  rename(passengers=all_total, flights=all_flights,booths=all_booths) %>%
  arrange(date,hour)
rm(ord2016, ord2017, ord2018, ord2019, ord2020)

```

### 2

> Do any rows contain missing data? If so, how many?
Are there any dates in the range from January 1, 2016 through June 30, 2020 that are missing? If so, which ones?

#### Solution

```{r}
count_na <- function(x)
{
  return ( sum(is.na(x) ) )
}

ord %>%
  summarize(sum(is.na(date)))
# No rows with no data in "date" column. 

all_dates <- tibble(
  date = seq( ymd("2016-01-01"), ymd("2020-06-30"), 1) )

ord_dates <- ord %>%
  select(date) %>%
  distinct()

all_dates %>%
  left_join(ord_dates, keep=TRUE) %>%
  filter(is.na(date.y))
```

- There was no missing data.
- "2016-03-07" "2016-03-08" "2016-03-09" "2018-05-08" "2019-10-28" "2019-10-29" "2019-10-30" "2020-02-08" were missing dates.

### 3

> Calculate the total numbers of flights and passengers in each month and year and store this information in a table.
Summarize this table to find the total number of passengers and flights in each year from 2016 - 2019.
Which year has the most of each?

#### Solution

```{r problem-3, message = FALSE}
data <- ord %>%
  
```

: 2019 had the most total flights and 2018 had the most total passengers.

### 4

>  Display the total number of passengers by month and year with a bar chart where month is the primary variable on the x-axis and there is a separate bar (not stacked, and filled with a different color) for each year. Add meaningful axis and legend labels and a title to this graph. (See the layer in the section below which uses the `scale_fill_discrete()` function to control the legend title. In addition, `guides()` can offer even finer control over legend characteristics.) Change the scale on the y axis so that values are printed as numbers with commas and not using scientific notation. (See the help for the **ggplot2** function `scale_y_continuous()` and the **scales** function `label_comma()`.) Describe any patterns or interesting trends that you see.

#### Solution

```{r problem-4}
ord_summary2 <- ord %>%
  group_by(year, month) %>%
  summarize(tot_passengers=sum(passengers))

ggplot(ord_summary2, aes(x=month, y=tot_passengers, fill=year)) +
  geom_col(position = "dodge") +
  xlab("Month") +
  ylab("Total Passengers") +
  ggtitle("Number of Passengers Per Month (2016 ~ 2020)")
  scale_y_continuous(label=comma)
```

- July and August are the months with largest total passengers.
- 

### 5

> Add a `weekend` column to the combined data set which is TRUE for Saturdays and Sundays and FALSE for other days.
Make a scatter plot with the average time for US passengers on the x-axis and the average time for non-US passengers on the y-axis.
Use different colors for weekend and weekdays.
Add a line to the plot that passes through the origin with a slope of one (explore `geom_abline()` to do this).
Add straight regression lines to the plot, separately for weekends and weekdays
(`geom_smooth()` with `method = "lm"`).
Plot the data from different years in different facets.
Change the color legend so that TRUE displays as "Weekend" and FALSE displays as "Weekday". (Use `scale_color_discrete()` and experiment with the `name` and `labels` arguments. )

> Are there any noteworthy patterns to the data?
> What are the primary differences between domestic and international flyers and are the patterns different on weekdays versus weekends?

```{r problem-5}
weekend_data <- ord %>%
  mutate(weekend=ifelse(wday=="Sat" | wday=="Sun", "TRUE", "FALSE")) %>%
  select(year, weekend, wday, us_avg_wait, non_us_avg_wait)

ggplot(weekend_data,aes(x=us_avg_wait, y=non_us_avg_wait, color=weekend)) +
  geom_point() +
  geom_smooth(method="lm") +
  facet_wrap(~year) +
  scale_color_discrete(name = "Weekend & Weekdays", labels = c("TRUE" = "Weekend","FALSE" = "Weekday"))
  
```

: 
- The average waiting time in weekday tends to be longer than that of weekend.
- Average weaiting time for foreigners tends to be longer than that of Americans.
- The difference between weekday and weekend average waiting time seems to be narrowed as the year passes.

### 6

>Calculate separately for each year, the fraction of cases (a case is a single hour on a single date) for which the average time to get through passport control is greater for non US passport holders than it is for passport holders. Comment on how these values relate to the graphs in the previous problem.

```{r problem-6}
data <- ord %>%
  group_by(year) %>%
  summarize(us=mean(us_avg_wait), non_us=mean(non_us_avg_wait)) %>%
  select(year, us, non_us)
data
```

: The average time to get through passport control for non-US passport holders is definitely longer than that of US citizens. However,
the gap between those two times starts decreasing as the year passes.

### 7

> Add a column named `booth_rate` to the data set which estimates the average number of passengers per booth per hour. For example, if 1000 passengers arrive between 05:00 and 06:00, the average wait time is 40 minutes, and there are 10 booths open, then an estimate of the total number of passengers per booth per hour could be computed like this: 1000/10 = 100 passengers per booth; (40 minutes per passenger * 1 hour per 60 minutes) = 2/3 hours per passenger; booth rate = 100 / (2/3) = (1000 * 60) / (10 * 40) = 150 passengers per booth per hour. This is an estimate because it assumes available booths change on the hour and it ignores how rates change when passenger wait durations stretch into the next time period.
Add another column called `time_of_day` which takes the value "overnight" from 1am to 5am, "early morning" from 5am to 8am, "morning" from 8am to noon, "afternoon" from noon to 5pm, and "early evening" from 5pm to 8pm, and "late evening" from 8pm to 1am.
Use `reorder()` to put the `time_of_day` variable in this order.

> After calculating this statistic, filter out cases where there are fewer than 200 total passengers, the average wait time is zero, or the booth rate is over 500. Make side_by_side boxplots of the booth rate versus the day of the week using different colors for each day of the week, different facets for each time of day,
and fill color white if it is a weekday and gray if it is on the weekend.
**Hints:** Use `case_when()` to set values of the `time_of_day`. Use `scale_fill_manual()` to set the fill values to white or gray.

>Which time of day has the lowest booth rate?
Do booth rates tend to be higher on the weekend or on weekdays during each time of day?
Is this effect large or small relative to variation in the booth rate within a day of week and time of day?

```{r problem-7}
q7_data1 <- ord %>%
  mutate(booth_rate = (passengers/booths) / (all_avg_wait / 60), 
         time_of_day= 
  case_when(
  (hour == "0100 - 0200" | hour == "0200 - 0300" | hour == "0300 - 0400" | hour == "0400 - 0500" ~ 'overnight'),
  (hour == "0500 - 0600" | hour == "0600 - 0700" | hour == "0700 - 0800" ~ 'early morning'),
  (hour == "0800 - 0900" | hour == "0900 - 1000" | hour == "1000 - 1100" | hour == "1100 - 1200" ~ 'morning'),
  (hour == "1200 - 1300" | hour == "1300 - 1400" | hour == "1400 - 1500" | hour == "1500 - 1600" | hour == "1600 - 1700" ~'afternoon'),
  (hour == "1700 - 1800" | hour == "1800 - 1900" | hour == "1900 - 2000" ~ 'early evening'),
  (hour == "2000 - 2100" | hour == "2100 - 2200" | hour == "2200 - 2300" | hour == "2300 - 0000" | hour == "0000 - 0100"~ 'late evening'))) %>%
  mutate(time_of_day_v2 = case_when(time_of_day == "overnight" ~ 1,
                                  time_of_day == "early morning" ~ 2,
                                  time_of_day == "morning" ~ 3,
                                  time_of_day == "afternoon" ~ 4,
                                  time_of_day == "early evening" ~ 5,
                                  time_of_day == "late evening" ~ 6)) %>%
  mutate(time_of_day = as.factor(time_of_day)) %>%
  mutate(weekend = ifelse(wday == "Sat" | wday == "Sun", "TRUE", "FALSE")) %>%
  filter( (passengers>=200) | (all_avg_wait != 0) | (booth_rate<=500) )

ggplot(q7_data1, aes(x=wday, y=booths,color=wday)) +
  geom_boxplot(aes(fill = weekend), position = "dodge") +
  facet_wrap(~reorder(time_of_day, time_of_day_v2)) +
  scale_fill_manual(values = c("white", "gray"))
```

- Overnight has the lowest booths rate.
- Weekend tends to have slightly higher booth rates.
-
